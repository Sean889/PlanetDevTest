// <auto-generated>
//	This code was generated by a Tool.
//
//	Changes to this file may cause incorrect behavior and will be lost if
//	the code is regenerated.
// <auto-generated>

using System;
using GL = global::OpenTK.Graphics.OpenGL.GL;

#pragma warning disable 168

namespace Shaders
{
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("ShaderCompiler.exe", "0.1.10")]
	public class PlanetShader : global::ShaderRuntime.GLShader
	{
		public static bool ImplementationSupportsShaders
		{
			get
			{
				return (new Version(GL.GetString(global::OpenTK.Graphics.OpenGL.StringName.Version).Substring(0, 3)) >= new Version(2, 0) ? true : false);
			}
		}
		static int ProgramID;
		private static global::ShaderRuntime.Utility.Counter Ctr = new global::ShaderRuntime.Utility.Counter(new Action(delegate{ GL.DeleteProgram(ProgramID); ProgramID = 0; }));
		public bool TransposeMatrix = false;
		public static int __MVP;
		public global::OpenTK.Matrix4 uniform_MVP;
		public static int __Displacement;
		public static int __Vertex;
		private static string VertexSource = "#version 430\n\n#pragma name PlanetShader\n\nlayout(location = 0) uniform mat4 MVP;\n\nlayout(location = 0) in vec3 Vertex;\nlayout(location = 1) in vec3 Normal;\nlayout(location = 2) in float Displacement;\n\nsmooth out vec3 vs_Normal;\nsmooth out float vs_Displacement;\n\nvoid main()\n{\n	gl_Position = MVP * vec4(Vertex, 1.0);\n	\n	vs_Normal = Normal;\n	vs_Displacement = Displacement / 128.0;\n}";
		private static string FragmentSource = "#version 430\n\nin vec3 vs_Normal;\nin float vs_Displacement;\n\nout vec3 colour;\n\nvoid main()\n{\n	colour = vec3(0.5, 0.0, vs_Displacement);\n}";
		private static void LoadShaders()
		{
			VertexSource = global::System.IO.File.ReadAllText(@"D:\Projects\Projects\C#\PlanetDevTest\Planet.vert");
			FragmentSource = global::System.IO.File.ReadAllText(@"D:\Projects\Projects\C#\PlanetDevTest\Planet.frag");
		}
		public static void CompileShader()
		{
			LoadShaders();
			ProgramID = GL.CreateProgram();
			int Vertex = GL.CreateShader(global::OpenTK.Graphics.OpenGL.ShaderType.VertexShader);
			GL.ShaderSource(Vertex, VertexSource);
			GL.CompileShader(Vertex);
			GL.AttachShader(ProgramID, Vertex);
			int Fragment = GL.CreateShader(global::OpenTK.Graphics.OpenGL.ShaderType.FragmentShader);
			GL.ShaderSource(Fragment, FragmentSource);
			GL.CompileShader(Fragment);
			GL.AttachShader(ProgramID, Fragment);
			GL.LinkProgram(ProgramID);
			global::System.Diagnostics.Debug.WriteLine(GL.GetProgramInfoLog(ProgramID));
			GL.DetachShader(ProgramID, Vertex);
			GL.DeleteShader(Vertex);
			GL.DetachShader(ProgramID, Fragment);
			GL.DeleteShader(Fragment);
			__MVP = GL.GetUniformLocation(ProgramID, "MVP");
			__Displacement = GL.GetAttribLocation(ProgramID, "Displacement");
			__Vertex = GL.GetAttribLocation(ProgramID, "Vertex");
		}
		public void Recompile()
		{
			GL.DeleteShader(ProgramID);
			ProgramID = 0;
			Compile();
		}
		public void Compile()
		{
			if(ProgramID == 0)
				CompileShader();
			Ctr++;
		}
		public void SetParameter<T>(string name, T value)
		{
			try
			{
				switch(name)
				{
					case "MVP":
						uniform_MVP = (global::OpenTK.Matrix4)(object)value;
						break;
					default:
						throw new global::ShaderRuntime.InvalidIdentifierException("There is no uniform variable named " + name + " in this shader.");
				}
			}
			catch(InvalidCastException e)
			{
				throw new global::ShaderRuntime.InvalidParameterTypeException("Invalid parameter type: " + name + " is not convertible from the type \"" + typeof(T).FullName + "\".");
			}
		}
		public T GetParameter<T>(string name)
		{
			try
			{
				switch(name)
				{
					case "MVP":
						return (T)(object)uniform_MVP;
					default:
						throw new global::ShaderRuntime.InvalidIdentifierException("There is no uniform variable named " + name + " in this shader.");
				}
			}
			catch(InvalidCastException e)
			{
				throw new global::ShaderRuntime.InvalidParameterTypeException("Invalid paramater type: " + name + " is not convertible to the type \"" + typeof(T).FullName + "\".");
			}
		}
		public int GetParameterLocation(string name)
		{
			switch(name)
			{
				case "MVP":
					return __MVP;
				case "Displacement":
					return __Displacement;
				case "Vertex":
					return __Vertex;
				default:
					throw new global::ShaderRuntime.InvalidIdentifierException("There is no parameter named " + name + ".");
			}
		}
		public void PassUniforms()
		{
			GL.UniformMatrix4(__MVP, TransposeMatrix, ref uniform_MVP);
		}
		public void UseShader()
		{
			GL.UseProgram(ProgramID);
			GL.EnableVertexAttribArray(__Displacement);
			GL.EnableVertexAttribArray(__Vertex);
		}
		public int GetShaderID()
		{
			if(ProgramID != 0)
				return ProgramID;
			throw new global::ShaderRuntime.ShaderNotInitializedException("The shader \"PlanetShader\" has not been initialized. Call Compile() on one of the instances or CompileShader() to compile the shader");
		}
		public void Dispose()
		{
			Ctr--;
		}
		public bool IsSupported
		{
			get
			{
				return ImplementationSupportsShaders;
			}
		}
		public global::System.Collections.Generic.IEnumerable<string> GetUniformNames()
		{
			yield return "MVP";
		}
	}
}
